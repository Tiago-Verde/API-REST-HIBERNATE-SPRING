Recentemente, ao me inscrever em uma oportunidade para seleção de novos talentos da Zup Innovation, me deparei com um desafio proposto para o processo de escolha dos candidatos onde tive que construir uma API REST que será utilizada para controlar endereços de usuários.Para desenvolvimento do exercício proposto, foi solicitado a utilização da linguagem Java associado aos frameworks Spring e Hibernate. Ambientados ao contexto, hora de colocar a mão na massa!**Primeiros passos: API REST? Spring? Hibernate? O que é tudo isso?**Para podermos avançar em nossa linha de raciocínio e começar a dar vida ao nosso projeto, precisamos antes compreender quais são as tecnologias e ferramentas que irão nos apoiar durante esse processo.**API REST**API é o acrônimo em inglês de *“Application Programming Interface”* (em português* “Interface de Programação de Aplicações”*). De uma maneira simplista, podemos dizer que dentro de uma determinada aplicação essa interface funciona como uma porta para que seus usuários possam utilizar os recursos dispostos na aplicação.Podemos encontrar um exemplo de API bastante prático no nosso dia a dia quando utilizamos em nosso smartphone aplicativos para verificar qual o clima de uma cidade. Ao selecionar a cidade estamos consultando via API quais os dados meteorológicos daquela região para uma segunda aplicação que é encarregada por manter esses dados atualizados.Em outras palavras, ao interagir com um computador ou sistema para recuperar informações ou executar uma função, a API ajudará a comunicar o que você quer ao sistema para que ele entenda e realize o que foi solicitado.REST significa “Representational State Transfer (em português “Transferência de Estado Representacional”). É um conjunto de padrões utilizados para que as requisições HTTP atendam as diretrizes definidas na arquitetura de uma aplicação. Resumidamente, o REST consiste em princípios que permitem a criação de um projeto com interfaces bem definidas que permitem, por exemplo, que aplicações se comuniquem umas com as outras.Dessa forma, quando nos referimos ao termo API REST, estamos falando sobre utilização de uma API para acessar os recursos de uma aplicação de modo que essa comunicação seja feita seguindo os padrões definidos pela arquitetura REST.**Spring e Hibernate**Spring é um framework desenvolvido em Java que possui uma série de pacotes de códigos prontos que facilitam a vida do desenvolvedor, evitando assim que se perca tempo escrevendo e reescrevendo códigos que basicamente são utilizados em rotinas repetitivas e configurações de projetos.Hibernate, assim como o Spring, também é um framework construído em Java utilizado como uma ferramenta para o mapeamento objeto-relacional. Basicamente, a função do Hibernate é reduzir a tarefa dos desenvolvedores quanto a necessidade de codificação manual de linguagem para banco de dados (SQL - Structured Query Language), artefato de grande ajuda principalmente quando estamos desenvolvendo aplicações de grande porte.Através das definições anteriores, de uma maneira mais coloquial, é possível pontuar tanto o Spring quanto o Hibernate como uma caixa de ferramentas com diversos módulos e utilidades que reduzem a complexidade da programação Java e tratam questões como a segurança, integração com a web, entre outras de uma maneira mais fluída e simplificada.**Entendendo o escopo: Objetivos do projeto**Introduzidos às tecnologias, agora podemos seguir com o entendimento do exercício proposto.Como visto no início desse artigo, nosso projeto consiste em criar uma aplicação que gerencie endereços de usuários e nossa API poderá ser consumida por outras aplicações via web. Essa informação por si só já nos concede um norte quando falamos de Spring.Dentre os recursos disponíveis no framework existe um módulo chamado “Spring MVC” que adiciona um conjunto de ferramentas que auxilia o desenvolvimento de aplicações web. Seguindo o padrão de implementação de arquitetura de software chamado Model-View-Controller (MVC), através do módulo “Spring MVC” otimizar a complexidade do desenvolvimento web quanto a necessidade de manter requisições HTTP, delegar responsabilidades de processamento de dados para outros componentes e preparar a resposta que precisa ser retornada ao sistema que o originou a requisição.Considerando a utilização do Hibernate, outro módulo que conseguimos verificar como elegível à utilização no exercício é o “Spring Data JPA” que tem como objetivo o tornar mais fácil a construção de aplicações que usam tecnologias de acesso a dados.Através do “Spring Data JPA” conseguimos melhorar significativamente a implementação de camadas de acesso a dados, reduzindo o esforço e otimizando o tempo de codificação. Como desenvolvedor você escreve suas interfaces de repositório e o Spring fica responsável por implementá-la automaticamente.**Primeiros passos da construção: Criando o projeto**Ao falamos sobre a inicialização de um projeto “Spring”, uma ferramenta que pode nos auxiliar no processo de configuração do projeto é o site “Spring Initializr” [(https://start.spring.io/)]((https://start.spring.io/).![Spring Initializr](https://www.ojundiaiense.com.br/blogs/imagens/Spring.jpg)Através da ferramenta podemos realizar a configuração inicial de nosso projeto, escolhendo qual ferramenta de build será utilizada (em nosso exemplo utilizaremos o Maven) e as principais dependências que serão utilizadas.Na imagem acima, além dos já citados “Spring WEB” e “Spring Data JPA”, podemos verificar também as seguintes dependências para o projeto:•	Spring Boot DevTools: responsável por auxiliar na reinicialização automática após mudanças realizadas no código.•	H2 Database: responsável por manter a base de dados da nossa aplicação.Optei por utilizar banco “H2 Database” para esse desafio por ser um banco de dados que pode ser armazenado em memória, sendo suficiente para testarmos nossa aplicação.Configurações realizadas, seguimos com o preenchimento das demais informações necessárias para gerar o pacote do projeto e na sequência efetuar o download do arquivo que a ferramenta criou. Abra esse arquivo com a IDE de sua preferência e pronto, a configuração inicial de seu projeto está pronta. Como estamos utilizando o Maven para compilar nosso projeto, para termos uma ideia do trabalho realizado pelo “Spring Initializr”, podemos conferir o arquivo pom.xml e verificar as dependências que escolhemos para o ponta pé inicial do projeto.![pom.xml](https://www.ojundiaiense.com.br/blogs/imagens/pom.png)É possível perceber que o arquivo pom.xml já vem configurado com o código necessário para que o Maven faça a gestão desses pacotes e, quando o projeto for aberto, automaticamente o download desses pacotes será efetuado.**Hands on: Hora de colocar a mão no código**Como nossa API será responsável pelo controle de endereços de usuários então precisamos criar nossas classes Usuário e Endereço, cada uma com suas respectivas propriedades.Conforme a orientação de nosso **PO** *(Product Owner*) um usuário deve ter as seguintes propriedades:* •	NOME* •	CPF* •	EMAIL* •	DATA DE NASCIMENTO* E, também, conforme levantamento realizado para atender as necessidades de nosso sistema, um endereço deve possuir as propriedades:* •	LOGRADOURO* •	NUMERO* •	COMPLEMENTO* •	BAIRRO* •	CIDADE* •	ESTADO* •	CEPAqui entra um detalhe importante que deve ser mencionado. Como estamos utilizando “Spring”, e uma de nossas dependências é o “Spring Data JPA”, vamos então usar essas nossas duas classes como entidades do banco de dados.Isso significa que faremos algumas anotações em cada uma das classes começando pela anotação @Entity. Isso fará com que nossa classe corresponda a uma tabela no banco de dados.Também iremos utilizar a anotação @Table e passaremos como parâmetro para essa anotação o nome da tabela que o JPA irá criar no banco de dados.Acima de cada propriedade iremos inserir a anotação @Column que irá transformar essa propriedade em uma coluna no banco de dados.Em complemento a essas informações, nos foi solicitado que as propriedades CPF e EMAIL devam compor um identificador único em nossa base, para isso utilizaremos o parâmetro “unique=true” na anotação @Column dessas propriedades.Dessa maneira nosso código ficará conforme exemplo apresentado na imagem seguinte:![@Column](https://www.ojundiaiense.com.br/blogs/imagens/column.png)O parâmetro name é o nome da coluna criada no banco de dadosApós configurar as propriedades que compõe as informações de nossas classes, iremos uma adicionar a propriedade ID tanto na classe usuário como na classe endereço e essa propriedade é de suma importância quando começarmos a relacionar usuários e endereços. Marcamos essa propriedade com a anotação @Id para informar o banco de dados que se trata do índice e adicionalmente inserimos a anotação @Generatedvalue.Essa última anotação tem a função de gerar a regra de negócio responsável pela criação do índice de nosso banco de dados. Em nosso exercício deixaremos ela sem nenhum parâmetro e isso fará com que o projeto fique responsável por resolver de maneira automática os índices que identificam os registros de nossas tabelas. Nosso código ficará assim:![@GeneratedValue](https://www.ojundiaiense.com.br/blogs/imagens/id.png)Pontuamos anteriormente que as classes Usuário e Endereço devem se relacionar entre si, afinal um usuário possui um ou mais endereços. Duas anotações utilizadas para fazer esse gerenciamento são @OneToMany e @ManyToOne. Para entender qual utilizar devemos refletir sobre a seguinte pergunta:Um usuário pode possuir muitos endereços, ou um endereço pode possuir muitos usuários?No nosso caso em específico, devido a uma regra de negócio levantada por nosso PO, um usuário pode possuir muitos endereços. Então são muitos endereços para um usuário, dessa forma nossa classe Endereço recebe a anotação @ManyToOne, e um usuário para muitos endereços, levando nossa classe Usuário a receber a anotação @OneToMany.Por fim, não podemos esquecer de criar os métodos de acesso getters e setters e o construtor de nossas duas classes.**Controllers: Os maestros de nosso exercício**Iremos agora trabalhar nas classes controladoras de nossa aplicação. Criadas como UsuarioController e EnderecoController, essas classes serão responsáveis por realizar o controle de acesso às classes Usuário e Endereço respectivamente.Para facilitar a compreensão de nosso entendimento, por exemplo, é através da classe UsuarioController que faremos operações de inserção, leitura, alteração, exclusão de nossos usuários. No futuro essas duas classes também irão servir como base para definirmos os endpoints de nossa aplicação.Nosso sistema pede por 3 endpoints sendo eles, o cadastro do usuário, o cadastro de endereços e a listagem dos endereços de um usuário específico. Para realizar essas tarefas precisamos de alguns métodos “comuns” como Salvar(), Deletar(), Listar().Então vamos precisar programar cada um deles? Não, meu querido amigo leitor. Para isso vamos criar duas interfaces que irão estender a classe JpaRepository(). Criaremos as interfaces UsuarioRepository e EnderecoRepository. Essas duas estendem a classe JpaRepository que já possui os métodos save(), find(), delete() entre outros prontos. Essa á uma das belezas de se programar usando frameworks!Voltamos então para as classes UsuarioController e EnderecoController.Como eu colocado alguns parágrafos atrás, são essas classes as responsáveis por gerenciar nossos endpoints, então devemos utilizar aqui também algumas anotações.Vamos começar com a anotação @RestController. Essa anotação basicamente indica que essa classe é um controller e ela será responsável por gerenciar a nossa próxima anotação, @RequestMapping.A @RequestMapping é quem faz o mapeamento de nosso endpoint. Em nosso exemplo, na classe UsuarioController utilizamos a @RequestMapping da seguinte forma:![@RestController](https://www.ojundiaiense.com.br/blogs/imagens/restcontroller.png)Nossa API irá responder no endereço web: http://nossaaplicacao.com/api/usuariosChamamos esse detalhamento de rota do endpoint implementado. Em uma analogia à um website, a rota “/api/usuarios” seria como a página inicial para acessar os recursos disponíveis da classe Usuário.Como nosso primeiro endpoint será o cadastro de usuários. Precisamos então criar um método addUser(), conforme a imagem:![addUser](https://www.ojundiaiense.com.br/blogs/imagens/adduser.png)A anotação @PostMapping indica que esse método será o responsável por atender à solicitação verbal POST do HTTP (Hypertext Transfer Protocol).ResponseEntity é a forma que utilizaremos para trazer a resposta HTTP para nossa solicitação. Quando nossa solicitação for atendida com sucesso a resposta retornada pela aplicação será 201 (CREATED) e caso haja falha no processo o nosso método retorna uma exceção 400 (BAD_REQUEST).Os códigos de status e significado de cada um deles também pode ser verificado em https://developer.mozilla.org/pt-BR/docs/Web/HTTP/Status.A expressão userRepository é uma instancia de nossa interface UserRepository e algo bem interessante a ser dito sobre isso é que graças a anotação @Autowired nós não precisamos mais usar a palavra reservada new na hora de instanciar o objeto da classe.![@Autowired](https://www.ojundiaiense.com.br//blogs/imagens/autowired.png)A nossa classe controladora de endereços também precisa ser anotada com @RestController e @RequestMapping. E nosso endpoint ficará assim:![@RequestMapping](https:www.jundiaiense.com.br/blogs/imagens/requestmapping.png)Faremos basicamente o mesmo na classe AddressController, onde iremos cadastrar	 endereços e então vamos criar um método chamado salvarEndereco(). A ideia é a mesma que a usada ao implementar o método addUser();![](https://www.ojundiaiense.com.br/blogs/imagens/SalvarEndereco.png)Com isso feito concluímos a solicitação de dois endpoints: o cadastro de usuários e o cadastro de endereços. Agora falta apenas o nosso último endpoint que será mostrar a listagem de endereços de um usuário específico.Iremos utilizar a classe EnderecoController para a implementação desse método que vamos chamar de getEnderecoByUsuarioId().![](https://www.ojundiaiense.com.br/blogs/imagens/getEnderecoByUsuarioId.png)**Executando o projeto: Hora de verificar nossa aplicação**Feito isso já podemos realizar os testes para ter a certeza de que nosso projeto atende as solicitações iniciais. Iremos utilizar o Postman para inserir os usuários, endereços e realizar as buscas.Vamos começar inserindo dois usuários, iremos utilizar JSON para a transmissão de dados. O primeiro usuário será:{    "cpf": "333.000.000-84",     "dataNascimento": "13/03/1989",    "email": "teste@teste.com",    "nome": "Fabiana Góes"}![](https://www.ojundiaiense.com.br/blogs/imagens/primeirousuario.png)O nosso segundo usuário será:{    "cpf": "222.000.000-10",     "dataNascimento": "28/07/1984",    "email": "tiago@teste.com",    "nome": "Tiago Rafael Góes"}![](https://www.ojundiaiense.com.br/blogs/imagens/segundousuario.png)Vamos inserir agora 3 endereços, um para o usuário Tiago e dois para o usuário Fabiana.O usuário Fabiana irá receber os seguintes endereços:{    "bairro": "Jd Bahia",     "cep": "2271-245",    "cidade": "Jundiai",    "complemento": "Casa 23",    "estado": "SP",    "logradouro": "Rua Palmas",    "numero": 137  }{    "bairro": "Leblon",     "cep": "11390-050",    "cidade": "Los Angeles",    "complemento": "",    "estado": "MG",    "logradouro": "Rua Tiburcio",    "numero": 38}![](https://www.ojundiaiense.com.br/blogs/imagens/primeiroendere%C3%A7o.png)![](https://www.ojundiaiense.com.br/blogs/imagens/segundoendereco.png)O usuário Tiago irá receber o endereço:{    "bairro": "Rami",     "cep": "11390-050",    "cidade": "Varzea Paulista",    "complemento": "",    "estado": "SP",    "logradouro": "Rua Minas Gerais",    "numero": 587}![](https://www.ojundiaiense.com.br/blogs/imagens/terceriroendereco.png)Nossos dois cadastros estão funcionando conforme o solicitado. O endpoint “/api/usuarios” quando acionado através do verbo POST via HTTP realiza a inserção de usuários e o endpoint “api/usuario/{id}/endereços” quando acionado através do verbo POST realiza a inserção de endereços.Nosso terceiro e último endpoint é a listagem dos endereços de um usuário específico. Vamos solicitar os endereços do usuário Fabiana através da rota “api/usuario/1”:![](https://www.ojundiaiense.com.br/blogs/imagens/busca.png)Feito isso encerramos aqui esse artigo, espero que esse conteúdo tenha sido proveitoso para você!